   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  11               	.global	CALLBACK_USB_GetDescriptor
  13               	CALLBACK_USB_GetDescriptor:
  14               	.LFB66:
  15               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2010.
   4:Descriptors.c ****               
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****       www.fourwalledcubicle.com
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 	  
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this 
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in 
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting 
  17:Descriptors.c ****   documentation, and that the name of the author not be used in 
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the 
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special 
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.  
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  41:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  42:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  43:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  44:Descriptors.c ****  *  more details on HID report descriptors.
  45:Descriptors.c ****  */
  46:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM KeyboardReport[] =
  47:Descriptors.c **** {
  48:Descriptors.c **** 	0x05, 0x01,          /* Usage Page (Generic Desktop)                    */
  49:Descriptors.c **** 	0x09, 0x06,          /* Usage (Keyboard)                                */
  50:Descriptors.c **** 	0xa1, 0x01,          /* Collection (Application)                        */
  51:Descriptors.c **** 	0x75, 0x01,          /*   Report Size (1)                               */
  52:Descriptors.c **** 	0x95, 0x08,          /*   Report Count (8)                              */
  53:Descriptors.c **** 	0x05, 0x07,          /*   Usage Page (Key Codes)                        */
  54:Descriptors.c **** 	0x19, 0xe0,          /*   Usage Minimum (Keyboard LeftControl)          */
  55:Descriptors.c **** 	0x29, 0xe7,          /*   Usage Maximum (Keyboard Right GUI)            */
  56:Descriptors.c **** 	0x15, 0x00,          /*   Logical Minimum (0)                           */
  57:Descriptors.c **** 	0x25, 0x01,          /*   Logical Maximum (1)                           */
  58:Descriptors.c **** 	0x81, 0x02,          /*   Input (Data, Variable, Absolute)              */
  59:Descriptors.c **** 	0x95, 0x01,          /*   Report Count (1)                              */
  60:Descriptors.c **** 	0x75, 0x08,          /*   Report Size (8)                               */
  61:Descriptors.c **** 	0x81, 0x03,          /*   Input (Const, Variable, Absolute)             */
  62:Descriptors.c **** 	0x95, 0x05,          /*   Report Count (5)                              */
  63:Descriptors.c **** 	0x75, 0x01,          /*   Report Size (1)                               */
  64:Descriptors.c **** 	0x05, 0x08,          /*   Usage Page (LEDs)                             */
  65:Descriptors.c **** 	0x19, 0x01,          /*   Usage Minimum (Num Lock)                      */
  66:Descriptors.c **** 	0x29, 0x05,          /*   Usage Maximum (Kana)                          */
  67:Descriptors.c **** 	0x91, 0x02,          /*   Output (Data, Variable, Absolute)             */
  68:Descriptors.c **** 	0x95, 0x01,          /*   Report Count (1)                              */
  69:Descriptors.c **** 	0x75, 0x03,          /*   Report Size (3)                               */
  70:Descriptors.c **** 	0x91, 0x03,          /*   Output (Const, Variable, Absolute)            */
  71:Descriptors.c **** 	0x95, 0x06,          /*   Report Count (6)                              */
  72:Descriptors.c **** 	0x75, 0x08,          /*   Report Size (8)                               */
  73:Descriptors.c **** 	0x15, 0x00,          /*   Logical Minimum (0)                           */
  74:Descriptors.c **** 	0x26, 231, 0,        /*   Logical Maximum (231)                         */
  75:Descriptors.c **** 	0x05, 0x07,          /*   Usage Page (Keyboard)                         */
  76:Descriptors.c **** 	0x19, 0x00,          /*   Usage Minimum (Reserved (no event indicated)) */
  77:Descriptors.c **** 	0x29, 231,           /*   Usage Maximum (Keyboard Application)          */
  78:Descriptors.c **** 	0x81, 0x00,          /*   Input (Data, Array, Absolute)                 */
  79:Descriptors.c **** 	0xc0                 /* End Collection                                  */
  80:Descriptors.c **** };
  81:Descriptors.c **** 
  82:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  83:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  84:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  85:Descriptors.c ****  *  process begins.
  86:Descriptors.c ****  */
  87:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  88:Descriptors.c **** {
  89:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  90:Descriptors.c **** 		
  91:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  92:Descriptors.c **** 	.Class                  = 0x00,
  93:Descriptors.c **** 	.SubClass               = 0x00,
  94:Descriptors.c **** 	.Protocol               = 0x00,
  95:Descriptors.c **** 				
  96:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  97:Descriptors.c **** 		
  98:Descriptors.c **** 	.VendorID               = 0x03EB,
  99:Descriptors.c **** 	.ProductID              = 0x2042,
 100:Descriptors.c **** 	.ReleaseNumber          = 0x0000,
 101:Descriptors.c **** 		
 102:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
 103:Descriptors.c **** 	.ProductStrIndex        = 0x02,
 104:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
 105:Descriptors.c **** 		
 106:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
 107:Descriptors.c **** };
 108:Descriptors.c **** 
 109:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
 110:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 111:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 112:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 113:Descriptors.c ****  */
 114:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 115:Descriptors.c **** {
 116:Descriptors.c **** 	.Config = 
 117:Descriptors.c **** 		{
 118:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 119:Descriptors.c **** 
 120:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 121:Descriptors.c **** 			.TotalInterfaces        = 1,
 122:Descriptors.c **** 				
 123:Descriptors.c **** 			.ConfigurationNumber    = 1,
 124:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 125:Descriptors.c **** 				
 126:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 127:Descriptors.c **** 			
 128:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 129:Descriptors.c **** 		},
 130:Descriptors.c **** 		
 131:Descriptors.c **** 	.HID_Interface = 
 132:Descriptors.c **** 		{
 133:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 134:Descriptors.c **** 
 135:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 136:Descriptors.c **** 			.AlternateSetting       = 0x00,
 137:Descriptors.c **** 			
 138:Descriptors.c **** 			.TotalEndpoints         = 1,
 139:Descriptors.c **** 				
 140:Descriptors.c **** 			.Class                  = 0x03,
 141:Descriptors.c **** 			.SubClass               = 0x01,
 142:Descriptors.c **** 			.Protocol               = HID_BOOT_KEYBOARD_PROTOCOL,
 143:Descriptors.c **** 				
 144:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 145:Descriptors.c **** 		},
 146:Descriptors.c **** 
 147:Descriptors.c **** 	.HID_KeyboardHID = 
 148:Descriptors.c **** 		{  
 149:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_t), .Type = DTYPE_HID},
 150:Descriptors.c **** 			
 151:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 152:Descriptors.c **** 			.CountryCode            = 0x00,
 153:Descriptors.c **** 			.TotalReportDescriptors = 1,
 154:Descriptors.c **** 			.HIDReportType          = DTYPE_Report,
 155:Descriptors.c **** 			.HIDReportLength        = sizeof(KeyboardReport)
 156:Descriptors.c **** 		},
 157:Descriptors.c **** 		
 158:Descriptors.c **** 	.HID_ReportINEndpoint = 
 159:Descriptors.c **** 		{
 160:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 161:Descriptors.c **** 
 162:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DESCRIPTOR_DIR_IN | KEYBOARD_EPNUM),
 163:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 164:Descriptors.c **** 			.EndpointSize           = KEYBOARD_EPSIZE,
 165:Descriptors.c **** 			.PollingIntervalMS      = 0x0A
 166:Descriptors.c **** 		},
 167:Descriptors.c **** };
 168:Descriptors.c **** 
 169:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 170:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 171:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 172:Descriptors.c ****  */
 173:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 174:Descriptors.c **** {
 175:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 176:Descriptors.c **** 		
 177:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 178:Descriptors.c **** };
 179:Descriptors.c **** 
 180:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 181:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 182:Descriptors.c ****  *  Descriptor.
 183:Descriptors.c ****  */
 184:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 185:Descriptors.c **** {
 186:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(7), .Type = DTYPE_String},
 187:Descriptors.c **** 		
 188:Descriptors.c **** 	.UnicodeString          = L"Arduino"
 189:Descriptors.c **** };
 190:Descriptors.c **** 
 191:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 192:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 193:Descriptors.c ****  *  Descriptor.
 194:Descriptors.c ****  */
 195:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 196:Descriptors.c **** {
 197:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(8), .Type = DTYPE_String},
 198:Descriptors.c **** 		
 199:Descriptors.c **** 	.UnicodeString          = L"Keyboard"
 200:Descriptors.c **** };
 201:Descriptors.c **** 
 202:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 203:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 204:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 205:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 206:Descriptors.c ****  *  USB host.
 207:Descriptors.c ****  */
 208:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue, const uint8_t wIndex, void** const Descr
 209:Descriptors.c **** {
  16               		.loc 1 209 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 210:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
 211:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 212:Descriptors.c **** 
 213:Descriptors.c **** 	void*    Address = NULL;
 214:Descriptors.c **** 	uint16_t Size    = NO_DESCRIPTOR;
 215:Descriptors.c **** 
 216:Descriptors.c **** 	switch (DescriptorType)
  23               		.loc 1 216 0
  24 0000 292F      		mov r18,r25
  25 0002 3327      		clr r19
  26 0004 2330      		cpi r18,3
  27 0006 3105      		cpc r19,__zero_reg__
  28 0008 01F0      		breq .L3
  29 000a 00F4      		brsh .L4
  30 000c 2130      		cpi r18,1
  31 000e 3105      		cpc r19,__zero_reg__
  32 0010 01F0      		breq .L5
  33 0012 2230      		cpi r18,2
  34 0014 3105      		cpc r19,__zero_reg__
  35 0016 01F4      		brne .L14
  36               	.LVL1:
 217:Descriptors.c **** 	{
 218:Descriptors.c **** 		case DTYPE_Device: 
 219:Descriptors.c **** 			Address = (void*)&DeviceDescriptor;
 220:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 221:Descriptors.c **** 			break;
 222:Descriptors.c **** 		case DTYPE_Configuration: 
 223:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor;
 224:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  37               		.loc 1 224 0
  38 0018 82E2      		ldi r24,lo8(34)
  39 001a 90E0      		ldi r25,0
  40               	.LVL2:
 223:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  41               		.loc 1 223 0
  42 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  43 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 225:Descriptors.c **** 			break;
  44               		.loc 1 225 0
  45 0020 00C0      		rjmp .L2
  46               	.LVL3:
  47               	.L4:
 216:Descriptors.c **** 	{
  48               		.loc 1 216 0
  49 0022 2132      		cpi r18,33
  50 0024 3105      		cpc r19,__zero_reg__
  51 0026 01F0      		breq .L7
  52 0028 2232      		cpi r18,34
  53 002a 3105      		cpc r19,__zero_reg__
  54 002c 01F4      		brne .L14
  55               	.LVL4:
 226:Descriptors.c **** 		case DTYPE_String: 
 227:Descriptors.c **** 			switch (DescriptorNumber)
 228:Descriptors.c **** 			{
 229:Descriptors.c **** 				case 0x00: 
 230:Descriptors.c **** 					Address = (void*)&LanguageString;
 231:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 232:Descriptors.c **** 					break;
 233:Descriptors.c **** 				case 0x01: 
 234:Descriptors.c **** 					Address = (void*)&ManufacturerString;
 235:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 236:Descriptors.c **** 					break;
 237:Descriptors.c **** 				case 0x02: 
 238:Descriptors.c **** 					Address = (void*)&ProductString;
 239:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 240:Descriptors.c **** 					break;
 241:Descriptors.c **** 			}
 242:Descriptors.c **** 			
 243:Descriptors.c **** 			break;
 244:Descriptors.c **** 		case DTYPE_HID: 
 245:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor.HID_KeyboardHID;
 246:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_t);
 247:Descriptors.c **** 			break;
 248:Descriptors.c **** 		case DTYPE_Report: 
 249:Descriptors.c **** 			Address = (void*)&KeyboardReport;
 250:Descriptors.c **** 			Size    = sizeof(KeyboardReport);
  56               		.loc 1 250 0
  57 002e 80E4      		ldi r24,lo8(64)
  58 0030 90E0      		ldi r25,0
  59               	.LVL5:
 249:Descriptors.c **** 			Size    = sizeof(KeyboardReport);
  60               		.loc 1 249 0
  61 0032 20E0      		ldi r18,lo8(KeyboardReport)
  62 0034 30E0      		ldi r19,hi8(KeyboardReport)
 251:Descriptors.c **** 			break;
  63               		.loc 1 251 0
  64 0036 00C0      		rjmp .L2
  65               	.LVL6:
  66               	.L5:
 220:Descriptors.c **** 			break;
  67               		.loc 1 220 0
  68 0038 82E1      		ldi r24,lo8(18)
  69 003a 90E0      		ldi r25,0
  70               	.LVL7:
 219:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  71               		.loc 1 219 0
  72 003c 20E0      		ldi r18,lo8(DeviceDescriptor)
  73 003e 30E0      		ldi r19,hi8(DeviceDescriptor)
  74 0040 00C0      		rjmp .L2
  75               	.LVL8:
  76               	.L3:
 227:Descriptors.c **** 			{
  77               		.loc 1 227 0
  78 0042 9927      		clr r25
  79               	.LVL9:
  80 0044 8130      		cpi r24,1
  81 0046 9105      		cpc r25,__zero_reg__
  82 0048 01F0      		breq .L9
  83 004a 00F0      		brlo .L10
  84 004c 0297      		sbiw r24,2
  85 004e 01F4      		brne .L14
  86               	.LVL10:
  87               	.LBB2:
 239:Descriptors.c **** 					break;
  88               		.loc 1 239 0
  89 0050 E0E0      		ldi r30,lo8(ProductString)
  90 0052 F0E0      		ldi r31,hi8(ProductString)
  91 0054 00C0      		rjmp .L15
  92               	.LVL11:
  93               	.L10:
  94               	.LBE2:
  95               	.LBB3:
 231:Descriptors.c **** 					break;
  96               		.loc 1 231 0
  97 0056 E0E0      		ldi r30,lo8(LanguageString)
  98 0058 F0E0      		ldi r31,hi8(LanguageString)
  99 005a 00C0      		rjmp .L15
 100               	.LVL12:
 101               	.L9:
 102               	.LBE3:
 103               	.LBB4:
 235:Descriptors.c **** 					break;
 104               		.loc 1 235 0
 105 005c E0E0      		ldi r30,lo8(ManufacturerString)
 106 005e F0E0      		ldi r31,hi8(ManufacturerString)
 107               	.LVL13:
 108               	.L15:
 109               	.LBE4:
 110               	.LBB5:
 239:Descriptors.c **** 					break;
 111               		.loc 1 239 0
 112               	/* #APP */
 113               	 ;  239 "Descriptors.c" 1
 114 0060 8491      		lpm r24, Z
 115               		
 116               	 ;  0 "" 2
 117               	.LVL14:
 118               	/* #NOAPP */
 119               	.LBE5:
 120 0062 90E0      		ldi r25,0
 121               	.LVL15:
 238:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 122               		.loc 1 238 0
 123 0064 9F01      		movw r18,r30
 240:Descriptors.c **** 			}
 124               		.loc 1 240 0
 125 0066 00C0      		rjmp .L2
 126               	.LVL16:
 127               	.L7:
 246:Descriptors.c **** 			break;
 128               		.loc 1 246 0
 129 0068 89E0      		ldi r24,lo8(9)
 130 006a 90E0      		ldi r25,0
 131               	.LVL17:
 245:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_t);
 132               		.loc 1 245 0
 133 006c 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 134 006e 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 135               	.LVL18:
 247:Descriptors.c **** 		case DTYPE_Report: 
 136               		.loc 1 247 0
 137 0070 00C0      		rjmp .L2
 138               	.LVL19:
 139               	.L14:
 214:Descriptors.c **** 
 140               		.loc 1 214 0
 141 0072 80E0      		ldi r24,0
 142 0074 90E0      		ldi r25,0
 213:Descriptors.c **** 	uint16_t Size    = NO_DESCRIPTOR;
 143               		.loc 1 213 0
 144 0076 20E0      		ldi r18,0
 145 0078 30E0      		ldi r19,0
 146               	.LVL20:
 147               	.L2:
 252:Descriptors.c **** 	}
 253:Descriptors.c **** 	
 254:Descriptors.c **** 	*DescriptorAddress = Address;
 148               		.loc 1 254 0
 149 007a FA01      		movw r30,r20
 150 007c 3183      		std Z+1,r19
 151 007e 2083      		st Z,r18
 255:Descriptors.c **** 	return Size;
 256:Descriptors.c **** }
 152               		.loc 1 256 0
 153 0080 0895      		ret
 154               		.cfi_endproc
 155               	.LFE66:
 157               	.global	ProductString
 158               		.section	.progmem.data,"a",@progbits
 161               	ProductString:
 162 0000 12        		.byte	18
 163 0001 03        		.byte	3
 164 0002 4B00      		.string	"K"
 165 0004 6500      		.string	"e"
 166 0006 7900      		.string	"y"
 167 0008 6200      		.string	"b"
 168 000a 6F00      		.string	"o"
 169 000c 6100      		.string	"a"
 170 000e 7200      		.string	"r"
 171 0010 6400      		.string	"d"
 172 0012 00        		.string	""
 173 0013 00        		.string	""
 174               	.global	ManufacturerString
 177               	ManufacturerString:
 178 0014 10        		.byte	16
 179 0015 03        		.byte	3
 180 0016 4100      		.string	"A"
 181 0018 7200      		.string	"r"
 182 001a 6400      		.string	"d"
 183 001c 7500      		.string	"u"
 184 001e 6900      		.string	"i"
 185 0020 6E00      		.string	"n"
 186 0022 6F00      		.string	"o"
 187 0024 00        		.string	""
 188 0025 00        		.string	""
 189               	.global	LanguageString
 192               	LanguageString:
 193 0026 04        		.byte	4
 194 0027 03        		.byte	3
 195 0028 0904      		.word	1033
 196               	.global	ConfigurationDescriptor
 199               	ConfigurationDescriptor:
 200 002a 09        		.byte	9
 201 002b 02        		.byte	2
 202 002c 2200      		.word	34
 203 002e 01        		.byte	1
 204 002f 01        		.byte	1
 205 0030 00        		.byte	0
 206 0031 C0        		.byte	-64
 207 0032 32        		.byte	50
 208 0033 09        		.byte	9
 209 0034 04        		.byte	4
 210 0035 00        		.byte	0
 211 0036 00        		.byte	0
 212 0037 01        		.byte	1
 213 0038 03        		.byte	3
 214 0039 01        		.byte	1
 215 003a 01        		.byte	1
 216 003b 00        		.byte	0
 217 003c 09        		.byte	9
 218 003d 21        		.byte	33
 219 003e 1101      		.word	273
 220 0040 00        		.byte	0
 221 0041 01        		.byte	1
 222 0042 22        		.byte	34
 223 0043 4000      		.word	64
 224 0045 07        		.byte	7
 225 0046 05        		.byte	5
 226 0047 81        		.byte	-127
 227 0048 03        		.byte	3
 228 0049 0800      		.word	8
 229 004b 0A        		.byte	10
 230               	.global	DeviceDescriptor
 233               	DeviceDescriptor:
 234 004c 12        		.byte	18
 235 004d 01        		.byte	1
 236 004e 1001      		.word	272
 237 0050 00        		.byte	0
 238 0051 00        		.byte	0
 239 0052 00        		.byte	0
 240 0053 08        		.byte	8
 241 0054 EB03      		.word	1003
 242 0056 4220      		.word	8258
 243 0058 0000      		.word	0
 244 005a 01        		.byte	1
 245 005b 02        		.byte	2
 246 005c 00        		.byte	0
 247 005d 01        		.byte	1
 248               	.global	KeyboardReport
 251               	KeyboardReport:
 252 005e 05        		.byte	5
 253 005f 01        		.byte	1
 254 0060 09        		.byte	9
 255 0061 06        		.byte	6
 256 0062 A1        		.byte	-95
 257 0063 01        		.byte	1
 258 0064 75        		.byte	117
 259 0065 01        		.byte	1
 260 0066 95        		.byte	-107
 261 0067 08        		.byte	8
 262 0068 05        		.byte	5
 263 0069 07        		.byte	7
 264 006a 19        		.byte	25
 265 006b E0        		.byte	-32
 266 006c 29        		.byte	41
 267 006d E7        		.byte	-25
 268 006e 15        		.byte	21
 269 006f 00        		.byte	0
 270 0070 25        		.byte	37
 271 0071 01        		.byte	1
 272 0072 81        		.byte	-127
 273 0073 02        		.byte	2
 274 0074 95        		.byte	-107
 275 0075 01        		.byte	1
 276 0076 75        		.byte	117
 277 0077 08        		.byte	8
 278 0078 81        		.byte	-127
 279 0079 03        		.byte	3
 280 007a 95        		.byte	-107
 281 007b 05        		.byte	5
 282 007c 75        		.byte	117
 283 007d 01        		.byte	1
 284 007e 05        		.byte	5
 285 007f 08        		.byte	8
 286 0080 19        		.byte	25
 287 0081 01        		.byte	1
 288 0082 29        		.byte	41
 289 0083 05        		.byte	5
 290 0084 91        		.byte	-111
 291 0085 02        		.byte	2
 292 0086 95        		.byte	-107
 293 0087 01        		.byte	1
 294 0088 75        		.byte	117
 295 0089 03        		.byte	3
 296 008a 91        		.byte	-111
 297 008b 03        		.byte	3
 298 008c 95        		.byte	-107
 299 008d 06        		.byte	6
 300 008e 75        		.byte	117
 301 008f 08        		.byte	8
 302 0090 15        		.byte	21
 303 0091 00        		.byte	0
 304 0092 26        		.byte	38
 305 0093 E7        		.byte	-25
 306 0094 00        		.byte	0
 307 0095 05        		.byte	5
 308 0096 07        		.byte	7
 309 0097 19        		.byte	25
 310 0098 00        		.byte	0
 311 0099 29        		.byte	41
 312 009a E7        		.byte	-25
 313 009b 81        		.byte	-127
 314 009c 00        		.byte	0
 315 009d C0        		.byte	-64
 316               		.text
 317               	.Letext0:
 318               		.file 2 "/usr/lib/avr/include/stdint.h"
 319               		.file 3 "/usr/lib/gcc/avr/5.4.0/include/stddef.h"
 320               		.file 4 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/../HighLevel/StdDescriptors.h"
 321               		.file 5 "../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 322               		.file 6 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccS23MYY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccS23MYY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccS23MYY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccS23MYY.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccS23MYY.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccS23MYY.s:13     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccS23MYY.s:199    .progmem.data:000000000000002a ConfigurationDescriptor
     /tmp/ccS23MYY.s:251    .progmem.data:000000000000005e KeyboardReport
     /tmp/ccS23MYY.s:233    .progmem.data:000000000000004c DeviceDescriptor
     /tmp/ccS23MYY.s:161    .progmem.data:0000000000000000 ProductString
     /tmp/ccS23MYY.s:192    .progmem.data:0000000000000026 LanguageString
     /tmp/ccS23MYY.s:177    .progmem.data:0000000000000014 ManufacturerString

NO UNDEFINED SYMBOLS
